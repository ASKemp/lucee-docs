var Promise = require('bluebird');
var _ = require('lodash');
var inherits = require('inherits');
var EventEmitter = require('events').EventEmitter;
var fs = require('graceful-fs-extra');
var path = require('path');
var url = require('url');
var winresourcer = Promise.promisify(require('winresourcer'));
var spawn = require('child_process').spawn;
var semver = require('semver');
var platformOverrides = require('platform-overrides');
var detectCurrentPlatform = require('./detectCurrentPlatform.js')

var NwVersions = require('./versions');
var Utils = require('./utils');
var Downloader = require('./downloader');
var platforms = require('./platforms');

// We inherit from EventEmitter for logging
inherits(NwBuilder, EventEmitter);
module.exports = NwBuilder;
function NwBuilder(options) {
    var self = this;
    var defaults = {
        files: null,
        appName: false,
        appVersion: false,
        platforms: ['osx32', 'osx64', 'win32', 'win64'],
        currentPlatform: detectCurrentPlatform(),
        version: 'latest',
        buildDir: './build',
        cacheDir: './cache',
        downloadUrl: 'http://dl.nwjs.io/',
        buildType: 'default',
        forceDownload: false,
        macCredits: false,
        macIcns: false,
        macZip: false,
        macPlist: false,
        winIco: null,
        argv: process.argv.slice(2)
    };
    // Intercept the platforms and check for the legacy platforms of 'osx' and 'win' and
    // replace with 'osx32', 'osx64', and 'win32', 'win64' respectively.
    if(typeof options.platforms != 'undefined'){
        if(options.platforms.indexOf('osx') >= 0){
            options.platforms.splice(options.platforms.indexOf('osx'), 1, 'osx32', 'osx64');
        }
        if(options.platforms.indexOf('win') >= 0){
            options.platforms.splice(options.platforms.indexOf('win'), 1, 'win32', 'win64');
        }
        if(options.platforms.indexOf('linux') >= 0){
            options.platforms.splice(options.platforms.indexOf('linux'), 1, 'linux32', 'linux64');
        }
    }
    // Assing options
    this.options = _.defaults(options, defaults);
    this._platforms = platforms;

    // Some Option checking
    if(!this.options.files) {
        throw new Error('Please specify some files');
    }

    if (this.options.platforms.length === 0)
        throw new Error('No platform to build!');

    // verify all the platforms specifed by the user are supported
    // this + previous check assures as we have only buildable platforms specified
    this.options.platforms.forEach(function(platform) {
        if (!(platform in platforms))
            throw new Error('unknown platform ' + platform)
    })

    this._platforms = _.cloneDeep(platforms)

    // clear all unused platforms
    for (var name in this._platforms) {
        if (this.options.platforms.indexOf(name) === -1)
            delete this._platforms[name]
    }
};

NwBuilder.prototype.build = function (callback) {
    var hasCallback = (typeof callback === 'function'),
        done = Promise.defer();

    // Let's create a node Webkit app
    this.checkFiles().bind(this)
        .then(this.resolveLatestVersion)
        .then(this.checkVersion)
        .then(this.platformFilesForVersion)
        .then(this.downloadNodeWebkit)
        .then(this.preparePlatformSpecificManifests)
        .then(this.createReleaseFolder)
        .then(this.copyNodeWebkit)
        .then(this.handleMacApp)
        .then(this.handleWinApp)
        .then(this.zipAppFiles)
        .then(this.mergeAppFiles)
        .then(function (info) {
            if(hasCallback) {
                callback(false, info);
            } else {
                done.resolve(info);
            }
        })
        .catch(function (error) {
            if(hasCallback) {
                callback(error);
            } else {
                done.reject(error);
            }
        });

    return hasCallback ? true : done.promise;
};

NwBuilder.prototype.run = function (callback) {
    var hasCallback = (typeof callback === 'function'),
        done = Promise.defer();

    // Let's run this node Webkit app
    this.checkFiles().bind(this)
        .then(this.resolveLatestVersion)
        .then(this.checkVersion)
        .then(this.platformFilesForVersion)
        .then(this.downloadNodeWebkit)
        .then(this.runApp)
        .then(function (info) {
            if(hasCallback) {
                callback(false, info);
            } else {
                done.resolve(info);
            }
        })
        .catch(function (error) {
            if(hasCallback) {
                callback(true, error);
            } else {
                done.reject(error);
            }
        });

    return hasCallback ? true : done.promise;
};


NwBuilder.prototype.checkFiles = function () {
    var self = this;

    return Utils.getFileList(this.options.files).then(function (data) {

        self._appPkg = data.json;
        self._files = data.files;

        return Utils.getPackageInfo(self._appPkg).then(function (appPkg) {
            self._appPkg = appPkg;

            if(!self.options.appName || !self.options.appVersion) {
                self.options.appName = (self.options.appName ? self.options.appName : appPkg.name);
                self.options.appVersion = (self.options.appVersion ? self.options.appVersion : appPkg.version);
            }
        });
    });

};

NwBuilder.prototype.resolveLatestVersion = function () {
    var self = this;

    if(self.options.version !== 'latest') return Promise.resolve();

    return NwVersions.getLatestVersion(self.options.downloadUrl).then(function(latestVersion){
        self.emit('log', 'Latest Version: v' + latestVersion);
        self.options.version = latestVersion;
    });
};

NwBuilder.prototype.checkVersion = function () {
    var version = this.options.version.replace('v', '');

    if(!semver.valid(this.options.version)){
        return Promise.reject('The version ' + this.options.version + ' is not valid.');
    } else {
        this._version = NwVersions.getVersionNames( version );
        this.emit('log', 'Using v' + this._version.version);
    }

    return Promise.resolve();
};

NwBuilder.prototype.platformFilesForVersion = function () {
    var self = this;

    this._forEachPlatform(function (name, platform) {

        var satisfied = !Object.keys(platform.files).every(function(range) {
            if (semver.satisfies(self._version.version, range)) {
                platform.files = platform.files[range];
                if('string' === typeof platform.files){
                    platform.files = [platform.files];
                }
                return false;
            }
            return true;
        });

        if (!satisfied) {
            throw new Error("Unsupported node-webkit version '" + self._version.version + "' for platform '" + platform.type + "'");
        }
    });

    return true;
};

NwBuilder.prototype.downloadNodeWebkit = function () {
    var self = this,
        downloads = [];

    this._forEachPlatform(function (name, platform) {
        platform.cache = path.resolve(self.options.cacheDir, self._version.version, name);
        platform.url = url.resolve(self.options.downloadUrl, self._version.platforms[name]);

        // Ensure that there is a cache folder
        if(self.options.forceDownload) {
            fs.removeSync(platform.cache);
        }

        fs.mkdirpSync(platform.cache);
        self.emit('log', 'Create cache folder in ' + path.resolve(self.options.cacheDir, self._version.version));

        if(!Downloader.checkCache(platform.cache, platform.files)) {
            downloads.push(
                Downloader.downloadAndUnpack(platform.cache, platform.url)
                    .catch(function(err){
                        if(err.statusCode === 404){
                            self.emit('log', 'ERROR: The version '+self._version.version+' does not have a corresponding build posted at http://dl.node-webkit.org/. Please choose a version from that list.')
                        } else {
                            self.emit('log', err.msg)
                        }

                        return Promise.reject('Unable to download nodewebkit.');
                    })
            );
            self.emit('log', 'Downloading: ' + platform.url);
        } else {
            self.emit('log', 'Using cache for: ' + name);
        }
    });

    return Promise.all(downloads)
        .then(function(data) {
            Downloader.clearProgressbar();
            return data;
        });
};

NwBuilder.prototype.buildGypModules = function () {
    // @todo
    // If we trigger a rebuild we have to copy
    // the node_modules to a tmp location because
    // we don't want to change the source files

};


NwBuilder.prototype.preparePlatformSpecificManifests = function(){

    if(!(this._appPkg.platformOverrides && Object.keys(this._appPkg.platformOverrides).length)){
        return true;
    }

    var self = this;

    this._forEachPlatform(function (name, platform) {

        var overrides = self._appPkg.platformOverrides;
        if (overrides[name] || overrides[name.substr(0, name.length-2)]) {

            platformOverrides({
                options: self._appPkg,
                platform: name
            }, function(err, result){
                if(err) throw(err);
                platform.platformSpecificManifest = result;
            });
        }
    });
};


NwBuilder.prototype.createReleaseFolder = function () {
    var self = this,
        releasePath,
        directoryCreationPromises = [];

    if (_.isFunction(self.options.buildType)) {
        releasePath = self.options.buildType.call(self.option